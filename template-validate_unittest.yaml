namespace: python
name: validate_unittest
description: Run the unittest using the tox tool
version: 1.0.0
maintainer: python-devel@oath.com
images:
    manylinux2010: quay.io/pypa/manylinux2010_x86_64
    manylinux1_32: quay.io/pypa/manylinux1_i686
    manylinux1_64: quay.io/pypa/manylinux1_x86_64
    ubuntu: ubuntu:latest
config:
    image: manylinux2010
    environment:
        BASE_PYTHON: /opt/python/cp37-cp37m/bin/python3.7
        GIT_SHALLOW_CLONE: false
        LANG: en_US.UTF-8
        TEST_RUNNER: pytest
        TOX_ARGS: ''
        TOX_ENVLIST: py36,py37,py38
    secrets:
        - CODECOV_TOKEN
        - COVERALLS_REPO_TOKEN
    steps:
    -   begin: echo "Starting ${SD_TEMPLATE_FULLNAME}"
    -   motd: |
            cat << EOF
            This step will run unittests using the tox tool
            EOF
    -   setup_environment: |
            export PATH=/opt/python/cp37-cp37m/bin:/opt/python/cp36-cp36m/bin:/opt/python/cp27-cp27m/bin:$PATH
            export BINDIR="`dirname ${BASE_PYTHON}`"
            if [ "$BINDIR" != "" ]; then
                export PATH="${BINDIR}:${PATH}"
            fi
    -   init_os: |
            if [ -e "/usr/bin/apt-get" ]; then
                echo "Updating the apt package list"
                apt-get update
                apt-get install -y python3 python3-venv python3-pip
                apt-get install -y python3.6-venv || /bin/true
                apt-get install -y python3.7-venv || /bin/true
                apt-get install -y python3.8-venv || /bin/true
            fi
            if [ ! -e "$BASE_PYTHON" ]; then
                BASE_PYTHON="`which python3`"
            fi
    -   install_pypirun: $BASE_PYTHON -m pip install pypirun
    -   update_version: echo "Update version"
    -   validate_code: pypirun tox tox $TOX_ARGS
    -   store_artifacts: |
            $BASE_PYTHON << EOF
            import os, shutil
            testdir = os.path.join(os.environ["SD_ARTIFACTS_DIR"], 'test')
            os.makedirs(testdir, exist_ok=True)
            for filename in os.listdir('.'):
                if not filename.endswith('.xml'):
                    continue
                if 'test' in filename or 'coverage' in filename:
                    print(f'Copying  {filename} -> {testdir}/{filename}', flush=True)
                    shutil.copy(filename, os.path.join(testdir, filename))
            EOF
    -   add_test_metadata: |
            $BASE_PYTHON -m pip install junitparser
            $BASE_PYTHON << EOF
            import json, os,subprocess, sys
            from junitparser import JUnitXml

            testdir = os.path.join(os.environ["SD_ARTIFACTS_DIR"], 'test')
            if not os.path.exists(testdir):
                print('No test metadata files to parse', flush=True)
                sys.exit(0)
 
            test_failed = 0
            test_run = 0
            test_ok = 0

            for filename in os.listdir(testdir):
                if 'test' not in filename:
                    continue
                    
                if not filename.endswith('.xml'):
                    continue
                    
                xml = JUnitXml.fromfile(os.path.join(testdir, filename))
                test_failed += xml.errors + xml.failures
                test_run += xml.tests - xml.skipped

            if test_run == 0:
                print('No tests run, not setting metadata', flush=True)
                sys.exit(0)
                
            test_ok = test_run - test_failed
            test_summary = f'{test_ok}/{test_run}'
            print(f'meta set tests.results {test_summary}')
            subprocess.call(['meta', 'set', 'tests.results', test_summary])
            status = {
                "status": "SUCCESS",
                "message": f"{test_summary} tests passed"
            }
            job_name = os.environ.get('SD_JOB_NAME', None)
            if job_name:
                job_name = job_name.split(':')[-1]
                print(f'meta set meta.status.{job_name}', json.dumps(status))
                subprocess.call(['meta', 'set', f'meta.status.{job_name}', json.dumps(status)])
            EOF
    -   add_coverage_metadata: |
            $BASE_PYTHON -m pip install coverage
            $BASE_PYTHON << EOF
            import os, subprocess, sys
            if not os.path.exists('.coverage'):
                print('No coverage data found', flush=True)
                sys.exit(0)
            try:
                output = subprocess.check_output(['coverage', 'report'])
            except (subprocess.CalledProcessError, FileNotFoundError):
                print('Not able to access coverage report, not updating coverage', flush=True)
                sys.exit(0)
            lines = output.decode(errors='ignore').split(os.linesep)
            
            for line in [ _.strip() for _ in lines]:
                if line.startswith('TOTAL'):
                    coverage_percentage = line.split()[-1].replace('%', '')
                    print(f'meta set tests.coverage {float(coverage_percentage)}')
                    subprocess.call(['meta', 'set', 'tests.coverage', str(float(coverage_percentage))])
            EOF
    -   codecov: |
            if [ "$CODECOV_TOKEN" != "" ]; then
                $BASE_PYTHON -m pip install codecov .[test]
                codecov
            fi
    -   end: echo "Ending ${SD_TEMPLATE_FULLNAME}"
