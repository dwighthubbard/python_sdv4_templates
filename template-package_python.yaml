namespace: python
name: package_python
description: Package the application as an sdist package
images:
    manylinux2014: quay.io/pypa/manylinux2014_x86_64
    manylinux2010: quay.io/pypa/manylinux2010_x86_64
    manylinux1_32: quay.io/pypa/manylinux1_i686
    manylinux1_64: quay.io/pypa/manylinux1_x86_64
    ubuntu: ubuntu:latest
version: 1.0.1
maintainer: python-devel@oath.com
config:
    image: manylinux2010
    environment:
        BASE_PYTHON: /opt/python/cp37-cp37m/bin/python3
        GIT_SHALLOW_CLONE: false
        LANG: en_US.UTF-8
        MANYLINUX: True
        PUBLISH: false
        TWINE_REPOSITORY_URL: https://upload.pypi.org/legacy/
        PYROMA_MIN_SCORE: 8
        PACKAGE_TAG: True
        PACKAGE_TYPES: sdist,wheel
        SETUP_ARGS: ''
    secrets:
        - PYPI_USER
        - PYPI_PASSWORD
        - TEST_PYPI_USER
        - TEST_PYPI_PASSWORD
        - GIT_DEPLOY_KEY
        - GIT_DEPLOY_KEY_PASSPHRASE
    steps:
    -   begin: echo "Starting ${SD_TEMPLATE_FULLNAME}"
    -   motd: |
            cat << EOF
            This job will generate python packages, check them and publish them to a python packaging
            repository.
            EOF
    -   init_os: |
            sd-cmd exec python/python_bootstrap@stable
            source /tmp/python_bootstrap.env
    -   setup_deploy_keys: |
            if [ ! -z "$GIT_DEPLOY_KEY" ]; then
                screwdrivercd_ssh_setup
                eval "$(ssh-agent -s)"
                screwdrivercd_github_deploykey
            fi
    -   install_dependencies: $BASE_PYTHON -m screwdrivercd.installdeps
    -   update_version: $BASE_PYTHON -m screwdrivercd.version
    -   package_code: $BASE_PYTHON -m  screwdrivercd.packaging.build_python
    -   check_packages: $BASE_PYTHON -m screwdrivercd.validation.validate_package_quality
    -   publish_packages: |
            $BASE_PYTHON << EOF
            import os, subprocess, sys
            package_dir = f'{os.environ["SD_ARTIFACTS_DIR"]}/packages'
            if not os.path.exists(package_dir):
               print('Package directory does not exist, no packages to validate', flush=True)
               sys.exit(0)
            if os.environ['PUBLISH'].lower() not in ['true', '1', 'on']:
                print('Publish is disabled, skipping publish operation', flush=True)
                sys.exit(0)
            if 'test.pypi.org' in os.environ['TWINE_REPOSITORY_URL']:
                print('Using test.pypi.org endpoint, getting user from TEST_PYPI_USER secret and password from TEST_PYPI_PASSWORD secret', flush=True)
                user = os.environ.get('TEST_PYPI_USER', None)
                password = os.environ.get('TEST_PYPI_PASSWORD', None)
            else:
                print('Using pypi.org endpoint, getting user from PYPI_USER secret and password from PYPI_PASSWORD secret', flush=True)
                user = os.environ.get('PYPI_USER', None)
                password = os.environ.get('PYPI_PASSWORD', None)
            if not user:
                print('Unable to publish to PYPI, user secret is not set', flush=True)
                sys.exit(1)
            if not password:
                print('Unable to publish to PYPI, password secret is not set', flush=True)
                sys.exit(1)
            os.environ['TWINE_USERNAME'] = user
            os.environ['TWINE_PASSWORD'] = password
            bindir = os.path.dirname(sys.executable)
            twine_cmd = os.path.join(bindir, 'twine')
            twine_env = {'TWINE_USERNAME': user, 'TWINE_PASSWORD': password}
            if not os.path.exists(twine_cmd):
                print('The twine command is missing', flush=True)
                sys.exit(1)
            print(f'Publishing to {os.environ["TWINE_REPOSITORY_URL"]} as with user {user}', flush=True)
            for filename in os.listdir(package_dir):
                print(f'Uploading {filename}', flush=True)
                command = [twine_cmd, 'upload', '--verbose', os.path.join(package_dir, filename)]
                print(f'Running: {" ".join(command)}')
                try:
                    subprocess.check_call(command)
                except subprocess.CalledProcessError as error:
                    print(f'Upload of package file {filename!r} failed', flush=True)
                    sys.exit(error.returncode)
            EOF
    -   tag_release: |
            $BASE_PYTHON << EOF
            import os
            import subprocess
            import sys
            
            if os.environ['PUBLISH'].lower() not in ['true', '1', 'on']:
                print('Publish is disabled, skipping tag operation', flush=True)
                sys.exit(0)
            if not os.environ.get('PACKAGE_TAG', 'True').lower() in ['1', 'true', 'on']:
                print('Tagging is disabled for this job')
                sys.exit(0)
            if not os.environ.get('GIT_DEPLOY_KEY', ''):
                print('Git deployment key is not present, cannot commit tags to the git repo')
                sys.exit(0)
            version = subprocess.check_output(['meta', 'get', 'package.version']).decode(errors='ignore')
            if version == 'null':
                print('No release version in metadata', flush=True)
                sys.exit(0)
                
            print('Creating tag', flush=True)
            try:
                message = subprocess.check_output(['git', 'log', '-n', '1']).decode(errors='ignore').split('\n')[4].strip()
            except (subprocess.CalledProcessError, KeyError):
                message = f'New release {version}'
            subprocess.call(['git', 'tag', '-a', f'v{version}', '-m', message])
            # subprocess.call(['git', 'tag', '-a', 'latest', '-m', f'Adding release {version}'])
            # subprocess.call(['git', 'tag', f'v{version}'])
            subprocess.call(['git', 'tag', '--force', '-m', message, 'latest'])
            
            print('Pushing the tags')
            try:
                subprocess.call(['git', 'push', '-f', '--tags'], timeout=60)
                # subprocess.call(['sd-step', 'exec', 'core/git', 'git push -f --tags'], timeout=30)
            except subprocess.TimeoutExpired:
                print('Timeout occurred pushing tags to the remote')
                print('Git remotes:')
                os.system('git remote -v')
            except subprocess.CalledProcessError:
                print('Push of git tag failed')
            EOF
    -   publish_delay: |
            $BASE_PYTHON << EOF
            import os, time
            
            if os.environ['PUBLISH'].lower() not in ['true', '1', 'on']:
                time.sleep(60)
            EOF
    -   end: echo "Ending ${SD_TEMPLATE_FULLNAME}"
