namespace: python
name: package_rpm
description: Package the application as a rpm package
images:
    manylinux2010: quay.io/pypa/manylinux2010_x86_64
    manylinux1_32: quay.io/pypa/manylinux1_i686
    manylinux1_64: quay.io/pypa/manylinux1_x86_64
    ubuntu: ubuntu:latest
version: 1.0.1
maintainer: python-devel@oath.com
config:
    image: manylinux2010
    environment:
        BASE_PYTHON: /opt/python/cp37-cp37m/bin/python3
        GIT_SHALLOW_CLONE: false
        LANG: en_US.UTF-8
        MANYLINUX: True
        PUBLISH: false
        TWINE_REPOSITORY_URL: https://upload.pypi.org/legacy/
        PYROMA_MIN_SCORE: 8
        PACKAGE_TYPES: sdist,wheel
        SETUP_ARGS: ''
    secrets:
        - PYPI_USER
        - PYPI_PASSWORD
        - TEST_PYPI_USER
        - TEST_PYPI_PASSWORD
    steps:
    -   begin: echo "Starting ${SD_TEMPLATE_FULLNAME}"
    -   motd: |
            cat << EOF
            This job will generate python packages, check them and publish them to a python packaging
            repository.
            EOF
    -   init_os: |
            if [ -e "/usr/bin/apt-get" ]; then
                echo "Updating the apt package list"
                apt-get update
                apt-get install -y python3 python3-venv python3-pip
            fi
    -   setup_environment: |
            export PATH=/opt/python/cp37-cp37m/bin:/opt/python/cp36-cp36m/bin:/opt/python/cp27-cp27m/bin:$PATH
            if [ "$AUDITWHEEL_PLAT" != "" ]; then
                export PATH="`ls -1d /opt/python/*|sort -r|while read dir; do echo -n $dir/bin:; done`:$PATH"
            fi
            if [ "$BASE_PYTHON" = "" ]; then
                BASE_PYTHON="`which python3`"
            fi
            export BINDIR="`dirname ${BASE_PYTHON}`"
            if [ "$BINDIR" != "" ]; then
                export PATH="${BINDIR}:${PATH}"
            fi    
    -   environment_keys: |
            $BASE_PYTHON << EOF
            import os
            keys = list(os.environ.keys())
            keys.sort()
            print(', '.join(keys))
            EOF
    -   install_rpm_deps: yum install -y rpm-build redhat-rpm-config
    -   install_utility: |
            $BASE_PYTHON -m pip install setuptools 
            $BASE_PYTHON -m pip install wheel invirtualenv
    -   update_version: |
            $BASE_PYTHON << EOF
            from configparser import ConfigParser
            import os
            import subprocess
            import sys
            
            version = subprocess.check_output(['meta', 'get', 'package.version']).decode(errors='ignore')
            if version == 'null':
                print('Unable to fetch package.version from the ci pipeline metadata', flush=True)
                sys.exit(0)
            print(f'Version set to {version}')
            parser = ConfigParser()
            with open('setup.cfg') as fh:
                parser.read_file(fh)
            if 'metadata' in parser.sections():
                version = parser.set('metadata', 'version', version)
                with open('setup.cfg', 'w') as fh:
                    parser.write(fh)
            EOF
    -   package_code: |
            $BASE_PYTHON <<EOF
            import os,shlex,subprocess,sys
            artifacts_dir = os.environ.get('SD_ARTIFACTS_DIR', 'artifacts')
            package_artifacts = os.path.join(artifacts_dir, 'packages')
            wheel_build_dir = os.path.join(artifacts_dir, 'wheelbuild')
            build_log_dir = os.path.join(artifacts_dir, 'logs/build')
            setup_args = shlex.split(os.environ.get('SETUP_ARGS', ''))
            manylinux = os.environ.get('MANYLINUX', 'True').lower() in ['1', 'true', 'on']
            plat = os.environ.get('AUDITWHEEL_PLAT', '')
            package_types = [ _.strip().lower() for _ in os.environ.get('PACKAGE_TYPES', 'sdist,wheel').split(',')]
            package_name = subprocess.check_output([sys.executable, 'setup.py', '--name']).decode(errors='ignore').strip()
            package_dir = os.environ.get('PACKAGE_DIR', package_name)
                     
            os.makedirs(package_artifacts, exist_ok=True)
            os.makedirs(build_log_dir, exist_ok=True)
            os.makedirs(wheel_build_dir, exist_ok=True)
            
            def run_and_log_output(command, logfile):
                with open(logfile, 'wb') as fh:
                    print(f'Running command: {" ".join(command)}', flush=True)
                    try:
                        output = subprocess.check_output(command, stderr=subprocess.STDOUT)
                        fh.write(output)
                    except subprocess.CalledProcessError as error:
                        print(f'Command {command!r} failed', flush=True)
                        if error.stdout:
                            print(error.stdout)
                        raise error
            
            failed = set()
            for package_type in package_types:
                if package_type == 'sdist':
                    print(f'Building sdist package', flush=True)
                    run_and_log_output(command=[sys.executable, 'setup.py', 'sdist'] + setup_args, logfile=f'{build_log_dir}/sdist_build.log')
                    if os.path.exists('dist'):
                        for filename in os.listdir('dist'):
                            print(f'Moving dist/{filename} -> {package_artifacts}/{filename}')
                            os.rename(f'dist/{filename}', f'{package_artifacts}/{filename}')
                elif package_type == 'wheel':
                    print('Building wheel package(s)', flush=True)
                    before = set(os.listdir('dist'))
                    run_and_log_output([sys.executable, 'setup.py', 'bdist_wheel'] + setup_args, logfile=f'{build_log_dir}/wheel_build.log')
                    after = set(os.listdir('dist'))
                    for filename in after - before:
                        if filename.endswith('none-any.whl'):
                            print('Package is generating a pure python wheel, disabling manylinux', flush=True)
                            manylinux = False
                            print(f'Moving dist/{filename} -> {package_artifacts}/{filename}')
                            os.rename(f'dist/{filename}', f'{package_artifacts}/{filename}')
                    if manylinux and plat:
                        print('Generating manylinux wheels', flush=True)
                        for entry in os.listdir('/opt/python'):
                            interpreter_dir = os.path.join('/opt/python', entry)
                            pip_command = f'{interpreter_dir}/bin/pip'
                            if os.path.isdir(interpreter_dir) and os.path.exists(pip_command):
                                print(f'Compiling wheel for the {entry!r} python interpreter', flush=True)
                                try:
                                    run_and_log_output([pip_command, 'wheel', '.', '-w', wheel_build_dir], logfile=f'{build_log_dir}/wheel_build_{entry}.log')
                                except subprocess.CalledProcessError:
                                    failed.add(entry)
                        for wheel in os.listdir(wheel_build_dir):
                            full_wheel_filename = os.path.join(wheel_build_dir, wheel)
                            if not wheel.startswith(package_name + '-'):
                                print(f'Removing dependency wheel {wheel!r}', flush=True)
                                os.remove(full_wheel_filename)
                                continue
                            if wheel.endswith('none-any.whl'):
                                # Not a binary wheel
                                continue
                            print(f'Bundling shared libraries for wheel package {wheel!r}', flush=True)
                            run_and_log_output(['auditwheel', 'repair', full_wheel_filename, '--plat', plat, '-w', wheel_build_dir], logfile=f'{build_log_dir}/wheel_auditwheel_{wheel}.log')
                            os.remove(full_wheel_filename)
                    for filename in os.listdir(wheel_build_dir):
                        print(f'Moving {wheel_build_dir}/{filename} -> {package_artifacts}/{filename}')
                        os.rename(f'{wheel_build_dir}/{filename}', f'{package_artifacts}/{filename}')
                print('', flush=True)
            if failed:
                print(f'Package build failed for {failed}')
            EOF
    -   package_rpm: |
            PACKAGE_VERSION=`meta get package.version`
            /tmp/testvenv/bin/invirtualenv create_package rpm
    -   store_package: |
            mkdir -p "$SD_ARTIFACTS_DIR/package/rpm"
            cp "*.rpm" "$SD_ARTIFACTS_DIR/package/rpm"
    -   check_packages: |
            $BASE_PYTHON << EOF
            import os
            import subprocess
            package_dir = f'{os.environ["SD_ARTIFACTS_DIR"]}/packages/rpm'
            for package in os.listdir(package_dir):
                package = os.path.join(package_dir, package)
                if not package.endswith('.rpm'):
                    continue
                print(f'Installing package {package!r}', flush=True)
                subprocess.check_call(['yum', 'install', '-y', package])
            EOF
    -   publish_packages: echo "Publish functionality is not yet implemented"
    -   disable_sonarqube: rm sonar-project.properties || true  
    -   end: echo "Ending ${SD_TEMPLATE_FULLNAME}"
